class Assignment_One_Scene extends Scene_Component {
    // The scene begins by requesting the camera, shapes, and materials it will need.
    constructor(context, control_box) {
        super(context, control_box);

        // First, include a secondary Scene that provides movement controls:
        if(!context.globals.has_controls)
            context.register_scene_component(new Movement_Controls(context, control_box.parentElement.insertCell()));

        // Locate the camera here (inverted matrix).
        const r = context.width / context.height;
        context.globals.graphics_state.camera_transform = Mat4.translation([0, 0, -35]);
        context.globals.graphics_state.projection_transform = Mat4.perspective(Math.PI / 4, r, .1, 1000);

        // At the beginning of our program, load one of each of these shape
        // definitions onto the GPU.  NOTE:  Only do this ONCE per shape
        // design.  Once you've told the GPU what the design of a cube is,
        // it would be redundant to tell it again.  You should just re-use
        // the one called "box" more than once in display() to draw
        // multiple cubes.  Don't define more than one blueprint for the
        // same thing here.
        const shapes = {
            'box': new Cube(),
            'ball': new Subdivision_Sphere(4),
            'prism': new TriangularPrism()
        }
        this.submit_shapes(context, shapes);

        // Make some Material objects available to you:
        this.clay = context.get_instance(Phong_Shader).material(Color.of(.9, .5, .9, 1), {
            ambient: .4,
            diffusivity: .4
        });
        this.plastic = this.clay.override({
            specularity: .6
        });
        
        this.lights = [new Light(Vec.of(10, 10, 20, 1), Color.of(1, .4, 1, 1), 100000)];

        this.blue = Color.of(0, 0, 1, 1);
        this.yellow = Color.of(1, 1, 0, 1);

        this.t = 0;
    }


    // Draw the scene's buttons, setup their actions and keyboard shortcuts, and monitor live measurements.
    make_control_panel() {
        this.key_triggered_button("Hover in Place", ["m"], () => {
            this.hover = !this.hover;
        });
        this.key_triggered_button("Pause Time", ["n"], () => {
            this.paused = !this.paused;
        });
    }

    draw_leg(graphics_state, object_base, offset, attitude){
        let m = Mat4.identity();

        //thigh
        let thigh_pos = m.times(Mat4.rotation(Math.PI/(-10), Vec.of(0,0,1)));
        this.shapes.box.draw(
            graphics_state,
            m.times(object_base).times(attitude).times(offset).times(thigh_pos).times(Mat4.scale(Vec.of(.5,2,.5))),
            this.plastic.override({color: this.blue})
        );

        //calf
        let calf_pos = m.times(Mat4.translation(Vec.of(0,-4.1,0))).times(Mat4.rotation(Math.PI/10, Vec.of(0,0,1)));
        this.shapes.box.draw(
            graphics_state,
            m.times(object_base).times(attitude).times(offset).times(calf_pos).times(Mat4.scale(Vec.of(.5,2,.5))),
            this.plastic.override({color: this.yellow})
        );

    }

    draw_antenna(graphics_state, object_base, offset, attitude){
        let m = Mat4.identity();
        
        let antenna_num = 0;
        while (antenna_num < 9){
            let joint_pos = m.times(Mat4.rotation(antenna_num, Vec.of(1,0,0))).times(Mat4.translation(Vec.of(0, antenna_num, 0)));
            this.shapes.box.draw(
                graphics_state,
                m.times(object_base).times(attitude).times(offset).times(joint_pos).times(Mat4.scale(Vec.of(.25,.25,.25))),
                this.plastic.override({color: this.yellow})
            )   
        }
    }

    draw_wing(graphics_state, object_base, offset, attitude, phase){
        let m = Mat4.identity();
        let center_wing = Mat4.translation(Vec.of(5,0,0));
        let wing_pos = m.times(center_wing).times(Mat4.rotation(Math.PI / 2 ,Vec.of(1,0,0))).times(Mat4.rotation(Math.PI * (3/4), Vec.of(0,0,1)));
        let flap = m.times(Mat4.rotation(Math.sin(this.t*2 + phase)/2, Vec.of(0,0,1)));//.times(base_pos.times(Mat4.scale(Vec.of(1,1,1))));//.times(attitude);
        this.shapes.prism.draw(
            graphics_state,
            m.times(object_base).times(attitude).times(offset).times(flap).times(wing_pos).times(Mat4.scale(Vec.of(7.071,7.071,.1))),
            this.plastic.override({color: this.blue})
        )
        //back of wing 
        let back_wing_pos = m.times(Mat4.translation(Vec.of(0,0,-5))).times(center_wing).times(Mat4.rotation(Math.PI / 4, Vec.of(0,1,0)));
        this.shapes.box.draw(
            graphics_state,
            m.times(object_base).times(attitude).times(offset).times(flap).times(back_wing_pos).times(Mat4.scale(Vec.of(3.5355,.1,3.5355))),
            this.plastic.override({color: this.blue})
        );
        //front of wing
        let front_wing_pos = m.times(Mat4.translation(Vec.of(2,0,5))).times(center_wing).times(Mat4.rotation(Math.PI / 4, Vec.of(0,1,0)));
        this.shapes.box.draw(
            graphics_state,
            m.times(object_base).times(attitude).times(offset).times(flap).times(front_wing_pos).times(Mat4.scale(Vec.of(5,.1,5))),
            this.plastic.override({color: this.yellow})
        );
    }

    draw_body(graphics_state, obj_center, attitude){
        let m = Mat4.identity();

        this.shapes.box.draw(
            graphics_state,
            m.times(obj_center).times(attitude).times(Mat4.scale(Vec.of(1,1,5))),
            this.plastic.override({color: this.yellow})
        );
        let head_pos = obj_center.times(attitude).times(Mat4.translation(Vec.of(0,0,7)));
        this.shapes.ball.draw(
            graphics_state,
            m.times(head_pos).times(Mat4.scale(Vec.of(2,2,2))),
            this.plastic.override({color: this.blue})
        );
        let abd_pos = obj_center.times(attitude).times(Mat4.translation(Vec.of(0,0,-8.0)));
        this.shapes.ball.draw(
            graphics_state,
            m.times(abd_pos).times(Mat4.scale(Vec.of(1,1,3))),
            this.plastic.override({color: this.blue})   
        );
        this.draw_wing(graphics_state, obj_center, Mat4.translation(Vec.of(1,.9,0)), attitude, 0);
        this.draw_wing(graphics_state, obj_center, Mat4.translation(Vec.of(1,-.9,0)), attitude.times(Mat4.rotation(Math.PI, Vec.of(0,1,0))).times(Mat4.rotation(Math.PI, Vec.of(1,0,0))), Math.PI);
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,0)),attitude);
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,0)),attitude.times(Mat4.rotation(Math.PI, Vec.of(0,1,0))));//.times(Mat4.rotation(Math.PI, Vec.of(1,0,0))));
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,3)),attitude);
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,-3)),attitude.times(Mat4.rotation(Math.PI, Vec.of(0,1,0))));
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,-3)),attitude);
        this.draw_leg(graphics_state,obj_center,Mat4.translation(Vec.of(-2,-2.75,3)),attitude.times(Mat4.rotation(Math.PI, Vec.of(0,1,0))));
        this.draw_antenna(graphics_state, obj_center, Mat4.translation(Vec.of(0,0,0)), attitude);
    }

    display(graphics_state) {
        // Use the lights stored in this.lights.
        graphics_state.lights = this.lights;

        // Variable m will be a temporary matrix that helps us draw most shapes.
        // It starts over as the identity every single frame - coordinate axes at the origin.
        let m = Mat4.identity();
                
        // Find how much time has passed in seconds, and use that to place shapes.
        if (!this.paused)
            this.t += graphics_state.animation_delta_time / 1000;
        const t = this.t;

        // TODO: Replace the below example code with your own code to draw the butterfly.
        let obj_center = Mat4.translation(Vec.of(0,0,0));
        let rot_x = 0;
        let rot_y = 0;
        let rot_z = 0;
        let attitude = Mat4.rotation(rot_x,Vec.of(1,0,0)).times(Mat4.rotation(rot_y,Vec.of(0,1,0))).times(Mat4.rotation(rot_z,Vec.of(0,0,1)));
        if (this.hover){
            obj_center = Mat4.translation(Vec.of(0, Math.cos(2*this.t), 0));
        }
        this.draw_body(graphics_state, obj_center, attitude);
    }
}

window.Assignment_One_Scene = window.classes.Assignment_One_Scene = Assignment_One_Scene;
